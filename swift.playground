import Foundation

//---------------------------------------------------------Variables, Strings--------------------------------------------------------------//
let name = "Taylor"
let age = 26
let message = "I am \(name) and I am \(age) years old"
print(age.isMultiple(of: 13))
print(message)
print(message.count)

//boolean
var isSaved = false;
isSaved.toggle()
print(isSaved)

//---------------------------------------------------------Arrays--------------------------------------------------------------//
var myItems = [4, 5, 3, 0, 7, 2, 3]
var colors = ["Red", "Green", "Blue"]
colors.append("Yellow")
myItems.remove(at: 2)
print(myItems[2])

//dictionary
let employee = [
    "name": "Peter",
    "job" : "Enterprise Architect",
    "lastname": "dkfj"
]
print(employee["name", default: "Unknown"])

//---------------------------------------------------------Sets -- duplicates and order are ignored in Sets----------------------------//
var numbers = Set([1,5,3,5,3,7,6])
print(numbers)
numbers.insert(10)
print(numbers.contains(11)) //runs instantly even if the set has 10 million items

//---------------------------------------------------------------Enums---------------------------------------------------------------//
enum Weekday {
    case monday, tuesday, wednesday, thursday, friday
}
var day = Weekday.monday
day = .friday
print(day)

//Type annonation
let player: String = "Tom"
let luckyNumber: Int = 13
let pi: Double = 3.14
let isEnabled: Bool = true

var albums: Array<String> = ["Backstreet boys", "The Green", "Nation"]
var user: Dictionary<String, String> = ["Name": "Peter", "job": "Enterprise Architect"]
var books: Set<String> = Set(["Python for Kids", "Release your Breaks"])

//another syntax for arrays and dictionaries
var albums1: [String] = ["Backstreet boys", "The Green", "Nation"]
var user1: [String: String] = ["Name": "Peter", "job": "Enterprise Architect"]
var books1: Set<String> = Set(["Python for Kids", "Release your Breaks"])

// creating empty collections
var teams: [String] = [String]()
var clues = [String]()

enum UIStyle {
    case light, dark, system
}
var style: UIStyle = .dark

//-----------------------------------------------------------condtions---------------------------------------------------------------------
let age1 = 16

if age1 < 12 {
    print("you cannot vote")
} else if age1 < 18 {
    print("you can soon vote")
} else {
    print("you can vote now")
}

let temp = 26

if temp >= 20 && temp <= 30 {
    print("It's a nice day")
} else if temp < 10 || temp < 20 {
    print("It's cold today")
}

//----------------------------------------------------------switch case---------------------------------------------------------------------
switch style {
case UIStyle.dark :
    print("dark theme active")
case UIStyle.light :
    print("light theme")
default:
    print("theme is other")
}

//---------------------------------------------------------ternary condition operator--------------------------------------------------------
let stockPrice = 99
var isExpensive : Bool = stockPrice > 100 ? true : false

//---------------------------------------------------------------------------Loops-----------------------------------------------------------
//for loop
let stocks = ["MSFT", "MSTR", "AVGO", "IBKR", "TSLA", "AMD"]

for stock in stocks {
    print("stock symbol is \(stock)")
}

for i in 1...10 {
    print(" 8 X \(i) = \(i * 8)")
}

var lyric = "Haters gonna"
//if you dont care about the variable, you can use underscore _
for _ in 1...5 {
    lyric +=  " hate"
}
print(lyric)

//while loop
var count = 10
while count > 0 {
    print("\(count)...")
    count -= 1
}

let files = ["adf.jpg", "work.txt", "sdfdf.jpg", "dsfdsfsdf.csv"]

for file in files {
    if file.hasSuffix(".jpg") == false {
        continue
    }
    print("Found picture \(file)")
}

//-----------------------------------------------------------------------Functions---------------------------------------------------------//
func printTimesTable(number: Int){
    for i in 1...10 {
        print("\(number) x \(i) = \(number *  i)")
    }
}
printTimesTable(number: 4)

func rollDice() -> Int {
    Int.random(in: 1...6)
}

let result = rollDice()
print(result)

func getUser() -> (firstName: String, lastName: String) {
    (firstName: "Peter", lastName: "Theo")
}
let user2 = getUser()
print("Name: \(user2.firstName) \(user2.lastName)")

let (firstName, _) = getUser()
print(firstName)

//if you dont want to pass variable name, then use under score
func isUppercase(_ input: String ) -> Bool {
    input == input.uppercased()
}
let result1 = isUppercase("HELLO HOW ARE YOU?")

func printTimesTable(for number:Int){
    for i in 1...10 {
        print("\(number) x \(i) = \(number * i)")
    }
}
printTimesTable(for: 5)

//default values in parametes

func greet(_ person: String, formal: Bool = false) {
    if formal {
        print("Welcome, \(person)")
    } else {
        print("Hi \(person)")
    }
}
print(greet("Peter", formal:true))
print(greet("Pradeep"))

//Errors
enum PasswordErrors: Error {
    case short, obvious
}

func checkPassword(_ password: String) throws -> String {
    if password.count < 5 {
        throw PasswordErrors.short
    } else if password == "12345" {
        throw PasswordErrors.obvious
    }
    
    if password.count < 10 {
        return "OK"
    } else {
        return "Good"
    }
}

do {
    let result = try checkPassword("12345yhyruytutui")
    print(result)
} catch PasswordErrors.short {
    print("Password is too short")
} catch PasswordErrors.obvious {
    print("Password is too obvious")
} catch { //generic catch all clause
    print("Some error occured")
}

//------------------------------------------------------------Closures-----------------------------------------------------------------//

// you can assign functionality to constant or variable
let sayHello = {
    print("Hello World")
}
sayHello() // you call the closure just like a function

//pass a parameter to the closure

let sayHello1 = { (name: String) -> String in // here the "in" keyword marks end of the segment of the parameters and the return type.
     "Hi, \(name)" //anything after the "in" keyword, is the body of the closure itself
}
print(sayHello1("James"))

let team = ["Gloria", "Susan", "Tiffiny", "Tasha"]
// ---------------------------------- closure filter ----------------------------------------------//
let namesStartWithT = team.filter({(name:String) -> Bool in
    name.hasPrefix("T")
})
print(namesStartWithT)

//---------------simplified clousre syntax---------------------------
let namesStartWithT1 = team.filter({ name in
    name.hasPrefix("T")
})
print(namesStartWithT1)

let namesStartWithT2 = team.filter { name in name.hasPrefix("T")} // trailing closure syntax
print(namesStartWithT2)

let namesStartWithT3 = team.filter {$0.hasPrefix("T") } //short parameter names, $0, $1, etc
print(namesStartWithT3)

//------------------------------------------------------------Struct-----------------------------------------------------------------//

//stuct let us make our own custom data types
struct Album {
    let title: String
    let artist: String
    var isReleased = true
    
    func printSummary() {
        print("\(title) by \(artist)")
    }
    mutating func removeFromSale() {
        isReleased = false
    }
}

var red = Album(title: "Red", artist: "Taylor Swift")
print(red.title)
red.printSummary()
print(red.isReleased)
red.removeFromSale()
print(red.isReleased)

struct Employee {
    let name: String
    var vacationAllowed = 14
    var vacationTaken = 0
    
    var vacationRemaining: Int {
        get {
            vacationAllowed - vacationTaken
        }
        set {
            vacationAllowed = vacationTaken + newValue
        }
    }
}

var person = Employee(name: "Peter")
person.vacationRemaining = 10
print(person.vacationAllowed)


//--------------------------------------Property Observers -- didSet and -----------------------------------------------------------------//
//property observers are pieces of code that runs when a property changes. there are two types. didSet (called after the change) and willSet (called before the property changes)

struct Game {
    var score = 0 {
        didSet { // called after the property is changed
            print("Score is now \(score)")
        }
        willSet { //called before the property value is changed
            print("Score is about to be changed. now it is \(score)")
        }
    }
}

var game = Game()
game.score += 20
game.score -= 5

// Initializers are special functions that run when new instance of the struct is created. It must make sure that all properties inside the struct have all values by the time it finishes. Swift will make one for you automatically for your struct. it is called member-wise initializers. sometimes you can make your own to have custom control

struct Player {
    let name: String
    let number: Int
    
    init(name: String) {
        self.name = name
        self.number = Int.random(in: 1...99)
    }
}

var player1 = Player(name: "Peter")
print(player1.number)

//----------------access controls: private, private(set), File Private, Public--------------------------------------///

struct BankAccount {
    private(set) var funds = 0 //cannot be changed outside of struct
    
    mutating func deposit(amount: Int){
        funds += amount
    }
    mutating func withdraw(amount: Int) {
        funds -= amount
    }
}

var bankAccount1 = BankAccount(funds: 1000)
bankAccount1.deposit(amount: 200)
print("new balance \(bankAccount1.funds)")
bankAccount1.withdraw(amount: 500)
print("new balance\(bankAccount1.funds)")

//-------------------------------Static Properties in Struct --------------------------------------///

struct AppData {
    static let version = "1.3 beta "
    static let settingsFile = "settings.json"
}

print(AppData.version) //access directly throught out the app without having to initilzie the struct


//------------------------------------------------Classes---------------------------------------------------------///

class Employee2 {
    let hours: Int
    
    init(hours: Int) { //initialize is mandatory
        self.hours = hours
    }
    
    func printSummary() {
        print("I work \(hours) hours a day)")
    }
}

class Developer: Employee2 {
    func work() {
        print("I'm coding for \(hours) hours a day")
    }
    //since it is not declaring any additional properties, it does not need sepearte init. it uses the parent init
    override func printSummary() {
        print("I spent \(hours) hours a day fighting over tabs vs spaces")
    }
}

var developer = Developer(hours: 20)
developer.work()
developer.printSummary()

class Vehicle {
    let isElectric: Bool
    
    init(isElectric: Bool) {
        self.isElectric = isElectric
    }
}

class Car: Vehicle {
    let isConvertinle: Bool
    
    init(isConvertinle: Bool, isElectric: Bool) { // initi is mandatory because there is additional property in class Car
        self.isConvertinle = isConvertinle
        super.init(isElectric: isElectric) //need to call parent init using super
    }
}

//copies of class objects share the same data whee as the structs don't. classes are of reference type and structs are value type.
class Actor {
    var name = "Nicolas Cage"
}

var actor1 = Actor()
var actor2 = actor1

actor2.name = "Tom Crise"
print(actor1.name)
print(actor2.name)

//---------------------class deinitializers ---------//
class Site {
    let id: Int
    
    init(id: Int) {
        self.id = id
        print("Site \(id): I've been created")
    }
    
    deinit {
        print("Site \(id): I've been destroyed")
    }
}

for i in 1...3 {
    let site = Site(id: i)
    print("Site \(site.id): I am in control")
} //as soon as the control leaves the iteration, the site created in that iteration will be deinitilized/destroyed

class Singer {
    var name = "Adele"
}

var singer = Singer()
singer.name = "Justin"
print(singer.name) // classes dont' need to have mutating property for their members. it can always change, but not the case for struct


//------------------------------------------------Protocols---------------------------------------------------------///
//protocols define functionality that we expect other types to support and swift will ensure they follow the rules correctly

protocol Vehicle1 {
    var name: String { get }
    var currentPassengers: Int { get set }
    func estimateTime(for distance: Int) -> Int
    func travel(distince: Int)
}

// you can conform multiple protocols also, by simplyng Vehicle1, Protocol2, Protocol3, etc.
//if you want to subclass and then conform to a protocol, add the class first and then protocal1, protocol2, etc.
struct Car1: Vehicle1 {
    let name = "Car"
    var currentPassengers = 1
    func estimateTime(for distance: Int) -> Int {
        distance / 50
    }
    func travel(distince: Int) {
        print("I am driving \(distince) km")
    }
    func openSunroof() {
        print("I's a nice day!")
    }
}

func commute(distance: Int, using vehicle: Vehicle1) {
    if vehicle.estimateTime(for: distance) > 100 {
        print("too slow!")
    } else {
        vehicle.travel(distince: distance)
    }
}

let car3 = Car1()
commute(distance: 100, using: car3)


//----------------------------------------------------------Extensions-----------------------------------------------------------///

extension String {
    func trimmed() -> String {
        self.trimmingCharacters(in: .whitespacesAndNewlines)
    }
    
    mutating func trim() {
        self = self.trimmed()
    }
    
    var lines: [String] {
        self.components(separatedBy: .newlines)
    }
}

var quote = "    hellow world lkdjfsalf  kaldsjf dsf  "
quote.trim()
print(quote)

let lyrics = """
Hello
How are you
What is happening
"""

print("number of lines in this string are: \(lyrics.lines.count)")

// ------------ Protocol extensions -----------------//
//protocol extensions let us add computed properties and methods to the whole protocol so that any types conforming to it will get access to them. For example, arrays, dictionaries and Sets are conformed to the common protocol called "Collections". so when we add a computeed property to that, all 3 of them will get access to it

extension Collection {
    var isNotEmpty: Bool { //computed property
        isEmpty == false
    }
}

let guests = ["Mario", "Goose", "Pathan", "Superman"]

if guests.isNotEmpty {
    print("Guest Count: \(guests.count)")
}

//---------------------------------------------------------- Optionals (Nullables in C#)------------------------------------------------///

let opposites = [
    "Mario": "Wario",
    "Luigi": "Walugigi"
]

let peachOpposite = opposites["Peach"]

if let marioOpposite = opposites["Mario"] {
    print("Mario's opposite is \(marioOpposite)")
}

func printSquare(of number: Int?) {
    guard let number = number else {
        print("Missing input")
        return
    }
    
    //if you are here, that menas number is present and not null
    print("\(number) x \(number) is \(number * number)")
}

printSquare(of: nil)

// Nil Colescent

let tvShows = ["Game of Thrones", "Dexter", "Breaking Bad"]
let favorite = tvShows.randomElement() ?? "None"
print(favorite)

let input = ""
let numner = Int(input) ?? 0
print(numner)

//---------------------------optional chaining ---------

let names = ["Arya", "Bran", "Robb", "Sansa"]

let chosen = names.randomElement()?.uppercased()
print("Next in line: \(chosen ?? "No one")")

///------optional try when there is an error

enum UserError: Error {
    case badID, networkFailed
}

func getUser(id: Int) throws -> String {
    throw UserError.networkFailed
}

if let user = try? getUser(id: 45) { //here we don't care what type of error we get, only care if we get user or not. if you want to know what kind of error is thrown, then use do, try catch blocks
    print("User: \(user)")
}

--------------Swift UI------------------------------
-----using Z-Stack:

import SwiftUI

struct ContentView: View {
    var body: some View {
        ZStack {
            VStack(spacing: 0) {
                Color.red
                Color.blue
            }
            Text("Your Content")
                .padding(50)
                .background(.ultraThinMaterial)
        }.ignoresSafeArea()
    }
}
------- Gradientes ---

--Liner Gradeint 
struct ContentView: View {
    var body: some View {
        ZStack {
            LinearGradient(stops:
                            [.init(color:.white, location: 0.45),
                             .init(color:.black, location: 0.55)
                            ], startPoint: .top, endPoint: .bottom)

            //LinearGradient(colors: [.white, .black], startPoint: .leading, endPoint: .trailing)
        }.ignoresSafeArea()
    }
}

--Radial Gradient 
struct ContentView: View {
    var body: some View {
        ZStack {
            RadialGradient(colors: [.blue, .black], center: .center, startRadius: 20, endRadius: 200)
        }.ignoresSafeArea()
    }
}

--Angular Gradient
struct ContentView: View {
    var body: some View {
        ZStack {
            AngularGradient(colors: [.blue, .red, .green, .purple, .blue], center: .center)
            AngularGradient(stops: [
                .init(color: .blue, location: 0.12),
                .init(color: .red, location: 0.40),
                .init(color: .yellow, location: 0.60),
                .init(color: .purple, location: 0.80),
                .init(color: .blue, location: 0.90)
                
            ], center: .center)
        }.ignoresSafeArea()
    }
}

---In-built gradient on any color
struct ContentView: View {
    var body: some View {
        ZStack {
            Text("Your Content here")
                .frame(maxWidth:.infinity, maxHeight: .infinity)
                .foregroundStyle(.white)
                .background(.indigo.gradient)
        }.ignoresSafeArea()
    }
}

-------------------------------------------------------Buttons and Images---------------------------------------------------------
import SwiftUI

struct ContentView: View {
    @State var message = ""
    @State var count = 0
    @State var isAlertShowing = false
    var body: some View {
        Button("Button 1") {}
            .buttonStyle(.bordered)
        Button("Button 2", role: .destructive) {}
            .buttonStyle(.bordered)
       
        Button("Button 1") {}
            .buttonStyle(.borderedProminent)
        Button("Button 2", role: .destructive) {}
            .buttonStyle(.borderedProminent)
        
        //Custom buttons
        Button {
            printHelloWorld()
        } label: {
            Text("Click me")
                .padding(15)
                .foregroundStyle(.white)
                .font(.largeTitle.weight(.semibold))
                .background(.red)
        }
        
        Image("newyork")
            .clipShape(.capsule)
            .shadow(radius: 5)
        
        // Buttons with sytem image icons (look up icon names using SF Symbols mac os app)
        Button("Delete", systemImage: "trash", role: .destructive, action: printHelloWorld)
        Button("Add", systemImage: "plus") {}
        Button("Edit", systemImage: "pencil"){}.tint(.green)
        Button("Upload", systemImage: "icloud.and.arrow.up.fill") {}.tint(.purple)
        
        //Buttons with action
        Button("Delete Selection", role: .destructive, action: printHelloWorld)
            .buttonStyle(.borderedProminent)
            .tint(.pink)
        Text("\(message)")
    }
    
    func printHelloWorld() {
        if count % 2 == 0 {
            message = "Hello World"
        } else {
            message = ""
        }
        count += 1
    }
}
#Preview {
    ContentView()
}

--------------------------TextField----------------------
 TextField("Amount", value: $checkAmount, format:
                            .currency(code: Locale.current.currency?.identifier ?? "USD"))
                    .keyboardType(.decimalPad)
                    .focused($isAmountFocused)

------------------------------------------------------
---------------------------------------Alerts---------------------------------------------
import SwiftUI
struct ContentView: View {
    @State var message = ""
    @State var count = 0
    @State private var isAlertShowing = false
    var body: some View {
        Button("Show Alert", role: .destructive) {
            isAlertShowing = true
        }
        .buttonStyle(.borderedProminent)
        .alert("This is Alert Title", isPresented: $isAlertShowing) {
            Button("OK", role: .destructive) {}
        } message: {
            Text("This is the body of the alert message")
        }
    }
}

----------------------------Guess the flag game--------------------------------------

//
//  ContentView.swift
//  GuessTheFlag
//
//  Created by noor on 2/5/25.
//

import SwiftUI


struct ContentView: View {
    @State private var countries = ["Estonia", "France", "Germany", "Ireland", "Italy", "Monaco", "Nigeria", "Poland", "Spain", "UK", "Ukraine", "US"]
    @State private var correctAnswer: Int = Int.random(in: 0...2)
    @State private var scoreTitle = ""
    @State private var scoreShowing = false
    @State private var score = 0
    @State private var gameOver = false
    @State private var questionCounter = 1
    var body: some View {
        ZStack {
            RadialGradient(stops: [
                .init(color: Color(red: 0.1, green: 0.2, blue: 0.45), location: 0.3),
                .init(color: Color(red: 0.76, green: 0.15, blue: 0.26), location: 0.3)
            ], center: .top, startRadius: 200, endRadius: 700)
            .ignoresSafeArea()
            VStack(spacing: 30) {
                Spacer()
                Text("Guess the Flag")
                    .foregroundStyle(.white)
                    .font(.largeTitle.bold())
                VStack(spacing: 15) {
                    VStack {
                        Text("Tap the flage of")
                            .foregroundStyle(.secondary)
                            .font(.subheadline.weight(.heavy))
                        Text(countries[correctAnswer])
                            .font(.largeTitle.weight(.semibold))
                    }
                    VStack(spacing:15) {
                        ForEach(0..<3){ number in
                            Button {
                                flagTapped(number)
                            } label: {
                                Image(countries[number])
                                    .clipShape(.capsule)
                                    .shadow(radius: 5)
                            } .alert(scoreTitle, isPresented: $scoreShowing){
                                Button("Continue?") {
                                    countries.shuffle()
                                    correctAnswer = Int.random(in: 0...2)
                                    
                                    if questionCounter > 9 {
                                        gameOver = true
                                    } else {
                                        questionCounter += 1
                                    }
                                }
                            }
                            .alert("Game OVer", isPresented: $gameOver){
                                Button("Restart") {
                                    questionCounter = 0
                                    score = 0
                                }
                                Button("Cancel") {
                                    
                                }
                            } message: {
                                Text("Game Over! Do you want to Restart?")
                            }
                        }
                        Text("Qestion \(questionCounter) of 10")
                    }
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 20)
                .background(.regularMaterial)
                .clipShape(.rect(cornerRadius: 20))
                
                Spacer()
                Spacer()
                
                VStack {
                    Text("Score: \(score)")
                        .foregroundStyle(.white)
                        .font(.title.bold())
                }
                Spacer()
            }.padding()
        }
    }
    
    func flagTapped(_ number: Int){
        if number == correctAnswer {
            score +=  1
            scoreTitle = "Correct. Your Score now is: \(score)"
            scoreShowing = true
            
        } else {
            scoreTitle = "Wrong. That's the flag of \(countries[number])"
            scoreShowing = true
        }
    }
}
#Preview {
    ContentView()
}

-------------------Use ternary operators instead of if conditions where possible for performance ---------
---below, if you use if conditions and use two different buttons, swiftUI needs to create two buttons and need to lot of work, where as if ternary operator is used, it only works with one button

import SwiftUI

struct ContentView: View {
    @State private var isUserRead = false
    var body: some View {
        Button("Hello World!") {
            isUserRead.toggle()
        }
        .foregroundStyle(isUserRead ? .blue: .red)
    }
}


---------modifierss-----
import SwiftUI

struct ContentView: View {
    @State private var isUserRead = false
    var body: some View {
        VStack {
            Text("Hello World")
                .font(.largeTitle) //this child modifier overrides the external vstack font modifer
            Text("Hello World")
            Text("Hello World")
            Text("Hello World")
            Text("Hello World")
        }
        .font(.title) //applies to all elements inside the VStack, but child modifers take precedence
    }
}
-----------------------Views as properties----------

import SwiftUI

struct ContentView: View {
    let view1 = Text("Hello World")
    let view2 = Text("How Are you")
    var body: some View {
        VStack {
            view1
            view2
                .foregroundStyle(.red)
        }
    }
}

----------views as computed properties ------
import SwiftUI

struct ContentView: View {
    //computed properties for views
    var view1: some View {
        VStack {
            Text("Hello world")
            Text("How are you")
        }
    }
    //using @ViewBuilder is recommended because that is exactly how body property is defined
    @ViewBuilder var view2 : some View {
        HStack {
            Text("I am fine..")
            Text("How r u doig")
        }
    }
    
    var body: some View {
        VStack {
            view1
            view2
                .foregroundStyle(.red)
        }
    }
}

------------------------------Custom Views -------------------------------

import SwiftUI
//Custom Vieww
struct capsuleText: View {
    var text: String
    var body: some View {
        Text(text)
            .padding()
            .font(.largeTitle)
            .background(.blue)
            .clipShape(.rect(cornerRadius: 15))
    }
}

struct ContentView: View {
    var body: some View {
        VStack(spacing: 15) {
            capsuleText(text: "Hello")
                .foregroundStyle(.white)
            capsuleText(text: "World")
                .foregroundStyle(.red)
        }
    }
}
---------------------------------------Custom ViewModifiers --------------------
import SwiftUI
//Custom ViewModifiers
struct Title : ViewModifier {
    func body(content: Content) -> some View {
        content
            .padding()
            .font(.largeTitle)
            .background(.blue)
            .foregroundStyle(.white)
            .clipShape(.rect(cornerRadius: 15))
    }
}

extension View {
    func TitleStyle() -> some View {
        modifier(Title())
    }
}

struct ContentView: View {
    var body: some View {
       Text("Hello World")
            .TitleStyle()
    }
}
----------------------------------------------Another Custom ViewModifier with additonal properties---------

//Custom ViewModifiers
struct Watermark : ViewModifier {
    var text: String
    func body(content: Content) -> some View {
        ZStack(alignment: .bottomTrailing){
            content
            Text(text)
                .font(.caption)
                .padding(5)
                .background(.black)
                .foregroundStyle(.white)
        }
    }
}

extension View {
    func Watermarked(with text: String ) -> some View {
        modifier(Watermark(text: text))
    }
}

struct ContentView: View {
    var body: some View {
        Color.blue
            .frame(width: 400, height: 300)
            .Watermarked(with: "Copyright @2025")
    }
}

----------------------------------------------------Custom Containers (like GridStack)----------------------------------------

import SwiftUI
//Custom Containers
struct GridStack<Content: View> : View {
    let rows: Int
    let columns: Int
    @ViewBuilder var content: (Int, Int) -> Content
    
    var body : some View {
        ForEach(0..<rows, id: \.self) { row in
            HStack {
                ForEach(0..<columns, id: \.self) { column in
                    content(row, column)
                }
            }
        }
    }
}

struct ContentView: View {
    var body: some View {
        GridStack(rows: 10, columns: 3) { (row, column) in
            Text("R\(row)C\(column)")
            Image(systemName: "\(row + column).circle")
        }
    }
}

--------------------------------------------------------Custom containers and Custom ViewModifiers----------------------------------

import SwiftUI
//Custom Containers
struct GridStack<Content: View> : View {
    let rows: Int
    let columns: Int
    @ViewBuilder var content: (Int, Int) -> Content
    
    var body : some View {
        ForEach(0..<rows, id: \.self) { row in
            HStack {
                ForEach(0..<columns, id: \.self) { column in
                    content(row, column)
                }
            }
        }
    }
}
//custom View Modifier
struct largeBlueTitle : ViewModifier {
    func body(content: Content) -> some View {
        content
            .padding()
            .foregroundStyle(.blue)
            .font(.largeTitle.weight(.semibold))
    }
}

extension View {
    func LargeBlueTitle() -> some View {
        modifier(largeBlueTitle())
    }
}

struct ContentView: View {
    var body: some View {
        VStack {
            GridStack(rows: 3, columns: 2) { (row, column) in
                Text("R\(row)C\(column)")
                Image(systemName: "\(row + column).circle")
            }
            .LargeBlueTitle()
        }
    }
}

-----------------------------Stepper --------------------------
import SwiftUI

struct ContentView: View {
    @State private var sleepAmount = 0.0
    var body: some View {
        Stepper("\(sleepAmount.formatted()) Hours", value: $sleepAmount, in: 4...12,
                step: 0.25)
            .padding()
    }
}
-----------------------------DatePicker and Dates --------------------------
import SwiftUI

struct ContentView: View {
    @State private var wakeUp = Date.now
    var body: some View {
        DatePicker("Enter a date", selection: $wakeUp, in: Date.now...)
            .labelsHidden()
        
        Text(Date.now.formatted(date: .abbreviated, time:.shortened))
        Text(Date.now.formatted(date: .long, time:.shortened))
        Text(exampleDates())
    }
    
    func exampleDates() -> String {
        let components = Calendar.current.dateComponents([.hour, .minute], from: .now)
        let hour = components.hour ?? 0
        let minute = components.minute ?? 0
        return "Date Components (hours: minutes):  \(hour):\(minute)"
    }
}
----------------------------------------------iOS app to predict the bed time using ML model created using CoreML-------------------------------

import CoreML
import SwiftUI

struct ContentView: View {
    @State private var wakeUp = Date.now
    @State private var sleepAmount = 8.0
    @State private var coffeeAmount = 1
    @State private var alertTitle = ""
    @State private var alertMessage = ""
    @State private var showingAlert = false
    
    var body: some View {
        NavigationStack {
            Form {
                VStack(alignment:.leading, spacing: 5) {
                    Text("When you do want to wake up?")
                        .font(.headline)
                    DatePicker("Please enter a time", selection: $wakeUp, displayedComponents: .hourAndMinute)
                        .labelsHidden()
                }
                
                VStack(alignment: .leading, spacing: 0) {
                    Text("Desired amount of sleep")
                        .font(.headline)
                    Stepper("\(sleepAmount.formatted()) hours", value: $sleepAmount, in: 4...12, step: 0.25)
                }
                
                VStack(alignment: .leading, spacing: 0) {
                    Text("Daily coffe intake")
                        .font(.headline)
                    Stepper("^[\(coffeeAmount) cup](inflect: true)", value: $coffeeAmount, in: 1...20)
                }
            }
            .navigationTitle("Better Rest")
            .toolbar {
                Button("Calculate", action: calculatedBedtime)
            }
            .alert(alertTitle, isPresented: $showingAlert){
                Button("OK") {}
            } message: {
                Text(alertMessage)
            }
        }
    }
    
    func calculatedBedtime() {
        do {
            let config = MLModelConfiguration()
            let model = try SleepCalculator(configuration: config)
            
            let components = Calendar.current.dateComponents([.hour, .minute], from: wakeUp)
            let hour = (components.hour ?? 0) * 60 * 60
            let minute = (components.minute ?? 0) * 60
            
            let prediction = try model.prediction(wake: Double(hour+minute),
                                estimatedSleep: sleepAmount, coffee: Double(coffeeAmount))
            
            let sleepTime = wakeUp - prediction.actualSleep
            
            alertTitle = "Your ideal bedtime is..."
            alertMessage = sleepTime.formatted(date: .omitted, time: .shortened)
            
        } catch {
            //something went wrong
            alertTitle = "Error"
            alertMessage = "Sorry, there was a problem calculating your bed time"
        }
        showingAlert = true
    }
    
}

----------------------------------------------------List View---------------------------------------

import SwiftUI

struct ContentView: View {
    var people = ["Steve", "Marcoon", "John", "Balu", "Peter", "Smith"]
    var body: some View {
        List {
            Section("First Section ") {
                Text("Hello world")
                Text("Hello World")
            }
            
            Section("Second section") {
                ForEach(0..<5) {
                    Text("\($0)")
                }
            }
            
            Section("Third section") {
                Text("Hello world")
                Text("Hello World")
            }
        }.listStyle(.grouped)
    }
}

#Preview {
    ContentView()
}
-------------------------------------reading resources from a bundle ----------------------
func testBundle() {
        if fileUrl = Bundle.main.url(forResource: "profile", withExtension: ".jpeg") {
            if let fileContents = try? String(contentsOf: fileUrl) {
                
            }
        }
    }
------------------------------------ Strings -------------------------
import SwiftUI

struct ContentView: View {
    var body: some View {
        let message = "a b c"
        var letters = getLettersOfTheString(message)
        ForEach(letters, id: \.self) { letter in
            Text("\(letter)")
        }
        
        let paragraph = """
                Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed
                ion ullamco laboris nisi ut aliquip ex ea commodo co dolore eu fugiat nulla pariatur.
                Excepteur sint occaec
                dent, sunt in culpa qui officia deserunt mollit anim id est laborum.
          """
        
        let lines = getLinesOftheString(paragraph)
        ForEach(lines, id: \.self) { line in
            var x = line.trimmingCharacters(in: .whitespaces)
            Text(x)
        }
    }
    
    func getLettersOfTheString(_ message: String) -> [String] {
        let letters = message.components(separatedBy: " ")
        return letters
    }
    
    func getLinesOftheString(_ message: String) -> [String] {
        let lines = message.components(separatedBy: "\n")
        return lines
    }
}

--------------------------String Spell Check using UITextChecker-------------------------------
import SwiftUI

struct ContentView: View {
    @State private var userInput = ""
    var body: some View {
        NavigationStack {
            Form {
                TextField(" ", text: $userInput)
                Section("Is It Spelled Correctly?") {
                    Text(IsItSpelleCorrectly(userInput) ? "Yes": "No")
                }
            }
            .navigationTitle("Spell Checker")
            .navigationBarTitleDisplayMode(.inline)
        }
    }
    
    func IsItSpelleCorrectly(_ word: String) -> Bool {
        var checker = UITextChecker()
        
        var range = NSRange(location: 0, length: word.utf16.count)
        let mispelledRange = checker.rangeOfMisspelledWord(in: word, range: range, startingAt: 0, wrap: false, language: "en")
        
        let allGood = mispelledRange.location == NSNotFound
        
        return allGood
    }
}

------------------ disable auto capitalize and auto correction --------
TextField("Enter your word", text: $newWord)
                        .textInputAutocapitalization(.never)
                        .autocorrectionDisabled()

------------------- simple Animation --------------
withAnimation {
            words.insert(answer, at: 0)
        }
----------------------------------------------Word Scramble Project ------------------------------
//
//  ContentView.swift
//  WordScramble
//  The game will show players a random eight-letter word, and ask them to make words out of it. For example, if the starter word is “alarming” they might spell “alarm”, “ring”, “main”, and so on.
//  Created by noor on 2/13/25.
//

import SwiftUI

struct ContentView : View {
    @State private var newWord = ""
    @State private var usedWords = [String]()
    @State private var rootWord = ""
    
    @State private var errorTitle = ""
    @State private var errorMessage = ""
    @State private var errorShowing = false
    @State private var userScore = 0
    
    var body: some View {
        NavigationStack {
            HStack {
                Text("Your Score:")
                Text("\(userScore)")
                    .font(.largeTitle)
                    .foregroundStyle(.green)
                    .fontWeight(.bold)
            }
            List {
                
                Section("Enter your word") {
                    TextField("Enter your word", text: $newWord)
                        .textInputAutocapitalization(.never)
                        .autocorrectionDisabled()
                    
                }
                Section {
                    ForEach(usedWords, id: \.self) { word in
                        HStack {
                            Image(systemName: "\(word.count).circle")
                            Text(word)
                        }
                    }
                }
            }
            .navigationTitle(rootWord)
            .toolbar {
                Button("Next Word") {
                    startGame()
                }
            }
        }
        .onSubmit(addNewWord)
        .onAppear(perform: startGame)
        .alert(errorTitle, isPresented: $errorShowing) {
            Button("OK") {}
        } message: {
            Text(errorMessage)
        }
        
    }
    
    func addNewWord() {
        let answer = newWord.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)
        guard answer.count > 2 else {return}
        guard answer != rootWord else {return}
        
        //some validations
        guard isOriginal(word: answer) else {
            wordError(title: "Duplicate word", message: "\(answer) already exists. be original!")
            return
        }
        
        guard isPossible(word: answer) else {
            wordError(title: "Not possible", message: "You cannot spell that world from \(rootWord)")
            return
        }
        
        guard isRealWord(word: answer) else {
            wordError(title: "Invalid word", message: "\(answer) is not a real word")
            return
        }
        
        withAnimation {
            usedWords.insert(answer, at: 0)
            userScore += answer.count
        }
        newWord = ""
    }
    
    func startGame() {
        if let startWordsUrl = Bundle.main.url(forResource: "start", withExtension: "txt") {
            let allWords = try? String(contentsOf: startWordsUrl).components(separatedBy: "\n")
            rootWord = allWords?.randomElement() ?? "sandworm"
            //clear existing values
            usedWords = [String]()
            newWord = ""
            return
        }
        fatalError("Could not load start.txt from bundle")
    }
    
    func isOriginal(word: String) -> Bool {
        !usedWords.contains(word)
    }
    
    func isPossible(word: String) -> Bool {
        var tempWord = rootWord
        
        for letter in word {
            if let pos = tempWord.firstIndex(of: letter) {
                tempWord.remove(at: pos)
            } else {
                return false
            }
        }
        return true
    }
    
    func isRealWord(word: String) -> Bool {
        let checker = UITextChecker()
        let range = NSRange(location: 0, length: word.count)
        let mispelledRange = checker.rangeOfMisspelledWord(in: word, range: range, startingAt: 0, wrap: false, language: "en")
        
        return mispelledRange.location == NSNotFound
    }
    
    func wordError(title: String, message: String) {
        errorTitle = title
        errorMessage = message
        errorShowing = true
    }
}

#Preview {
    ContentView()
}

--------------------------------------------------------------------------------------Animations-------------------------------------------------
import SwiftUI

struct ContentView: View {
    @State private var animationAmount = 1.0
    var body: some View {
        Button("Tap me") {
            animationAmount += 1
        }
        .padding(50)
        .background(.red)
        .foregroundStyle(.white)
        .clipShape(.circle)
        .scaleEffect(animationAmount)
        .blur(radius: (animationAmount - 1) * 3)
        .animation(.default, value: animationAmount)
    }
}

other animation types:
.animation(.easeInOut(duration: 2), value: animationAmount)
.animation(.linear(duration: 0.4), value: animationAmount)
.animation(.spring(duration: 1, bounce: 0.9), value: animationAmount)
.animation(
            .easeInOut(duration: 2)
                .delay(0.3),
            value: animationAmount)
.animation(
            .easeInOut(duration: 2)
                .repeatCount(4, autoreverses: true),
            value: animationAmount)
.animation(
            .easeInOut(duration: 2)
                .repeatForever(autoreverses: true),
            value: animationAmount)
------------------------------------------------------------------Cool pulsating button with Overlay shape animation---------------------------------

import SwiftUI

struct ContentView: View {
    @State private var animationAmount = 1.0
    var body: some View {
        Button("Tap me") {
            //animationAmount += 1
        }
        .padding(50)
        .background(.red)
        .foregroundStyle(.white)
        .clipShape(.circle)
        .overlay(
            Circle()
                .stroke(.red)
                .scaleEffect(animationAmount)
                .opacity(2 - animationAmount)
                .animation(
                    .easeOut(duration: 2)
                        .repeatForever(autoreverses: false),
                    value: animationAmount)
        )
        .onAppear {
            animationAmount = 2
        }
    }
}

----------------------------------------------Animating Bindings-----------------------------------------------
import SwiftUI

struct ContentView: View {
    @State private var animationAmount = 1.0
    var body: some View {
        VStack {
            Stepper("Select an amount", value: $animationAmount.animation(
                .easeInOut(duration: 2)
            ), in: 1...10)
            
            Spacer()
            
            Button("OK") {
                animationAmount += 1
            }
            .padding(50)
            .background(.red)
            .foregroundStyle(.white)
            .clipShape(.circle)
            .scaleEffect(animationAmount)
            
        }
    }
}

--------------------------------------------Explicit Animation bindings-----------------------------------------
import SwiftUI

struct ContentView: View {
    @State private var animationAmount = 0.0
    var body: some View {
        Button("Tap Me") {
            withAnimation(.spring(duration: 2, bounce: 0.5)) {
                animationAmount += 360;
            }
        }
        .padding(50)
        .background(.red)
        .foregroundStyle(.white)
        .clipShape(/*@START_MENU_TOKEN@*/Circle()/*@END_MENU_TOKEN@*/)
        .rotation3DEffect(
            .degrees(animationAmount),axis: (x: 1.0, y: 0.0, z: 0.0)
        )
    }
}

--------------------------------------------------------Controlling animation stack --------------------------
import SwiftUI

struct ContentView: View {
    @State private var enabled = false
    var body: some View {
        Button("Tap Me") {
            enabled.toggle()
        }
        .frame(width: 200, height: 200)
        .background(enabled ? .blue : .red)
        .foregroundStyle(.white)
        .animation(.default, value:enabled)
        .clipShape(.rect(cornerRadius: enabled ? 60: 0))
        .animation(.spring(duration: 1, bounce: 0.9), value: enabled)
    }
}

--------------------------------------------Gestures------------------------------------------------
--dragging a card - implicit animation

import SwiftUI

struct ContentView: View {
    @State private var dragAmount = CGSize.zero
    var body: some View {
        LinearGradient(colors: [.red, .yellow], startPoint: .topLeading, endPoint: .bottomTrailing)
            .frame(width: 300, height: 200)
            .clipShape(.rect(cornerRadius: 10))
            .offset(dragAmount)
            .gesture(
                DragGesture()
                    .onChanged { dragAmount = $0.translation }
                    .onEnded { _ in dragAmount = CGSize.zero }
            )
            .animation(.bouncy, value: dragAmount)
    }
}
-----dragging a card - explicit animation 
import SwiftUI

struct ContentView: View {
    @State private var dragAmount = CGSize.zero
    var body: some View {
        LinearGradient(colors: [.red, .yellow], startPoint: .topLeading, endPoint: .bottomTrailing)
            .frame(width: 300, height: 200)
            .clipShape(.rect(cornerRadius: 10))
            .offset(dragAmount)
            .gesture(
                DragGesture()
                    .onChanged { dragAmount = $0.translation }
                    .onEnded { _ in
                        withAnimation(.bouncy) {
                            dragAmount = CGSize.zero
                        }
                    }
            )
    }
}

----------------------------------------Animating Gestures-----------------------------------------------------

import SwiftUI

struct ContentView: View {
    let letters = Array("Hello SwiftUI")
    
    @State private var dragAmount = CGSize.zero
    @State private var enabled = false
    
    var body: some View {
        HStack(spacing:0) {
            ForEach(0..<letters.count, id:\.self){ num in
                Text(String(letters[num]))
                    .padding(5)
                    .font(/*@START_MENU_TOKEN@*/.title/*@END_MENU_TOKEN@*/)
                    .background(enabled ? .blue :  .red)
                    .offset(dragAmount)
                    .animation(.linear.delay(Double(num) / 20), value: dragAmount)
            }
        }
        .gesture(
            DragGesture()
                .onChanged {  dragAmount = $0.translation }
                .onEnded{ _ in
                    dragAmount = .zero
                    enabled.toggle()
                }
        )
    }
}
------------------------------------------------------------Showing and Hiding Views with Transition modifiers------------

import SwiftUI

struct ContentView: View {
    @State private var isRectShowing = false
    
    var body: some View {
        Button("Tap me") {
            withAnimation {
                isRectShowing.toggle()
            }
        }
        if isRectShowing {
            Rectangle()
                .fill(.red)
                .frame(width: 300, height:200)
                .transition(.asymmetric(insertion: .scale, removal: .opacity))
        }
    }
}

---------------------------------------------------Custom transitions using ViewModifer-------------------------------------------------------------------------
import SwiftUI

struct RotateCornerModifier : ViewModifier {
    let amount: Double
    let anchor: UnitPoint
    func body(content: Content) -> some View {
        content
            .rotationEffect(.degrees(amount), anchor: anchor)
            .clipped()
    }
}

extension AnyTransition {
    static var pivot : AnyTransition {
        .modifier(active: RotateCornerModifier(amount: -90, anchor: .topLeading),
                identity: RotateCornerModifier(amount:0, anchor: .topLeading)
        )
    }
}

struct ContentView: View {
    @State private var IsRedRectShowing = false
    
    var body: some View {
        ZStack {
            Rectangle()
                .fill(.blue)
                .frame(width: 300, height:200)
            
            if IsRedRectShowing {
                Rectangle()
                    .fill(.red)
                    .frame(width: 300, height: 200)
                    .transition(.pivot)
            }
        }
        .onTapGesture {
            withAnimation {
                IsRedRectShowing.toggle()
            }
        }
        
    }
}

--------------------------------------------------Observable on Class--------------------------------------------------

@Observable
class User {
    var firstname = ""
    var lastName = ""
}

struct ContentView: View {
     @State private var user = User()
    var body: some View {
        VStack {
            TextField("Enter your name", text: $user.firstname)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .padding(.bottom, 5)
            
            TextField("Enter your name", text: $user.lastName)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .padding(.bottom, 5)
                
            Text("Your name is: \(user.firstname), \(user.lastName)")
                .frame(maxWidth: /*@START_MENU_TOKEN@*/.infinity/*@END_MENU_TOKEN@*/, alignment: .leading)
                
        }
        .padding()
    }
}

---------------------------------------Sheets - Displaying an another view using Sheet with dismiss button------------------------------------
import SwiftUI

struct AnotherView: View {
    @Environment(\.dismiss) var dismiss
    let name: String
    
    var body: some View {
        Text("Hello \(name)")
        Button("Dismiss") {
            dismiss()
        }
    }
}

struct ContentView: View {
    @State private var showingSheet = false
    var body: some View {
        Button("Show Sheet") {
            showingSheet.toggle()
        }
        .sheet(isPresented: $showingSheet) {
            AnotherView(name: "Chris")
        }
        
    }
}
----------------------------------------Deleting Rows from a list ---------------------------------------------------------

import SwiftUI

struct ContentView: View {
    @State var numbers = [Int]()
    @State var currentNumber = 1
    var body: some View {
        NavigationStack {
            VStack {
                List {
                    ForEach(numbers, id:\.self) {
                        Text("Row \($0)")
                    }
                    .onDelete(perform: deleteRows)
                }
                
                Button("Add a row") {
                    numbers.append(currentNumber)
                    currentNumber += 1
                }
            }
            .toolbar {
                EditButton()
            }
        }
    }
    
    func deleteRows(at offsets: IndexSet) {
        numbers.remove(atOffsets: offsets)
    }
}
------------------------------App Storage (property wrapper around UserDefaults) : saving values to the device so that they can suvive between app restarts (user preferences, etc)---------------------------------------


import SwiftUI

struct ContentView: View {
    @AppStorage("tap") private var tapCount = 0
    var body: some View {
        Button("Tap Count \(tapCount)") {
            tapCount += 1
        }
    }
}

----------------------------User Defaults: Saving values that can survive between app restarts (user preferences, etc)-----------------------------------------------
import SwiftUI

struct ContentView: View {
    @State private var tapCount = UserDefaults.standard.integer(forKey: "tapCount")
    var body: some View {
        Button("Tap Count \(tapCount)") {
            tapCount += 1
            UserDefaults.standard.setValue(tapCount, forKey: "tapCount")
        }
    }
}
---------------------------------------------Saving Objects into UserDefaults using Codable, JsonEncoder and JsonDecoder----------------------------------------------
import SwiftUI
struct User: Codable {
    var firstName: String
    var lastName: String
}
struct ContentView: View {
    @State private var user = User(firstName: "Chris", lastName: "Smith")
    let names = ["Smith", "Will", "Rob", "Tom", "Kyle", "Rebecca", "Kate"]
    
    var body: some View {
        VStack {
            Text("Your name is: \(user.firstName)")
                .padding(.bottom, 5)
            
            Button("Change User") {
                user.firstName = names[Int.random(in: 0..<7)]
                //Save User object to user defaults
                let encoder = JSONEncoder()
                if let userData = try? encoder.encode(user) {
                    UserDefaults.standard.set(userData, forKey: "userData")
                }
            }
        }
        .onAppear() {
            let decoder = JSONDecoder()
            //optional binding with multiple conditions to unwrap multiple optional values using single if statement
            if let userData =  UserDefaults.standard.data(forKey: "userData"),
                let user1 = try? decoder.decode(User.self, from: userData) {
                    user = user1
                }
        }
    }
}
--------------------------------------------working with Identifiable items in swift UI------------------------------------------------
import SwiftUI

struct Expense : Identifiable {
    let id = UUID()
    let name: String
    let type: String
    let amount: Double
}

@Observable
class Expenses {
    var items = [Expense]()
}

struct ContentView: View {
    @State private var expenses = Expenses()
    var body: some View {
        NavigationStack {
            List {
                ForEach(expenses.items) { item in
                    Text("\(item.name)")
                }
                .onDelete(perform: removeItems)
            }
            .navigationTitle("iExpense")
            .toolbar {
                Button("Add") {
                    let newItem = Expense(name: "Lunch", type: "Personal", amount: 10.0)
                    expenses.items.append(newItem)
                }
                EditButton()
            }
        }
    }
    
    func removeItems(at offsets : IndexSet) {
        expenses.items.remove(atOffsets: offsets)
    }
}
-----------------------------------------------------------------------iExpense app---------------------------------------------------------------
//
//  ContentView.swift
//  iExpense
//
//  Created by noor on 2/20/25.
//

import SwiftUI

struct ExpenseItem : Identifiable, Codable {
    var id = UUID()
    let name: String
    let type: String
    let amount: Double
}

@Observable
class Expenses {
    var items = [ExpenseItem]() {
        didSet {
            if let encoded = try? JSONEncoder().encode(items) {
                UserDefaults.standard.setValue(encoded, forKey: "Items")
            }
        }
    }
    
    init() {
        if let savedItems = UserDefaults.standard.data(forKey: "Items") {
            if let decodedItems = try? JSONDecoder().decode([ExpenseItem].self, from: savedItems) {
                items = decodedItems
                return
            }
        }
        items = []
    }
}

struct ContentView: View {
    @State private var expenses = Expenses()
    @State private var showingExpenseView = false
    var body: some View {
        NavigationStack {
            List {
                Section("Business") {
                    ForEach(expenses.items.filter {$0.type == "Business"}) { item in
                        ExpenseRow(item: item)
                    }
                    .onDelete(perform: { offsets in
                        removeItems(at: offsets, type: "Business")
                    })
                }
                
                Section("Personal") {
                    ForEach(expenses.items.filter {$0.type == "Personal"}) { item in
                        ExpenseRow(item: item)
                    }
                    .onDelete(perform: { offsets in
                        removeItems(at: offsets, type: "Personal")
                    })
                }
            }
            .navigationTitle("iExpense")
            .toolbar {
                Button("Add Expense", systemImage: "plus") {
                    showingExpenseView = true
                }
                EditButton()
            }
            .sheet(isPresented: $showingExpenseView) {
                AddView(expenses: expenses)
            }
        }
    }
    
    func removeItems(at offsets : IndexSet, type: String) {
        let filteredItems = expenses.items.filter { $0.type == type }
        let indicesToDelete = offsets.map { filteredItems[$0].id }
        expenses.items.removeAll { indicesToDelete.contains($0.id) }
    }
}

//reusable view
struct ExpenseRow : View {
    let item : ExpenseItem
    var body: some View {
        HStack {
            VStack(alignment: .leading) {
                Text("\(item.name)")
                    .font(.headline)
                Text("\(item.type)")
                    .foregroundStyle(.gray)
            }
            Spacer()
            Text(item.amount, format: .currency(code: Locale.current.currency?.identifier ?? "USD"))
                .foregroundStyle(item.amount > 100 ? .red : (item.amount > 25 ? .blue : .green))
                .fontWeight(item.amount > 100 ? .bold : .regular)
        }
    }
}
#Preview {
    ContentView()
}

------Addview -----

struct AddView: View {
    @State private var name = ""
    @State private var type = "Personal"
    @State private var amount = 0.0
    let types = ["Personal", "Business"]
    var expenses: Expenses
    @Environment(\.dismiss) var dismiss
    
    var body: some View {
        NavigationStack {
            Form() {
                TextField("Enter name of the expense", text: $name)
                Picker("Type of Expense", selection: $type) {
                    ForEach(types, id: \.self) {
                        Text("\($0)")
                    }
                }
                TextField("Amount", value: $amount, format: .currency(code: "USD"))
                    .keyboardType(.decimalPad)
            }
            .navigationTitle("Add Expense")
            .toolbar {
                Button("Save") {
                    let newExpense = ExpenseItem(name: name, type: type, amount: amount)
                    expenses.items.append(newExpense)
                    dismiss()
                }
            }
        }
    }
}
-----------------------------------------------------------------------Images------------------------------------
import SwiftUI

struct ContentView: View {
    var body: some View {
        Image(.aldrin)
            .resizable()
            .scaledToFit()
            .containerRelativeFrame(.horizontal) { size, axis in
                size * 0.75
            }
    }
}
---------------------------------------------------------LazyVStack - loads only required views on demand as user scrolls through----------------------
import SwiftUI

var count = 0

struct CustomText : View {
    let text: String
    var body: some View {
        Text(text)
            .font(.title)
    }
    
    init(text: String) {
        count +=  1
        print("\(count) creating custom text")
        self.text = text
    }
}

struct ContentView: View {
    var body: some View {
        ScrollView {
            LazyVStack {
                ForEach(0..<150) {
                    CustomText(text: " Item \($0)")
                }
            }
            .frame(maxWidth: .infinity)
        }
    }
}
------------------------------------------------------NavigationLink ---------------------------------------
import SwiftUI

struct ContentView : View {
    var body: some View {
        NavigationStack {
            NavigationLink("Tap me") {
                Text("Detail View")
            }
            .navigationTitle("Swift UI")
        }
    }
}
------------------------
import SwiftUI

struct ContentView : View {
    var body: some View {
        NavigationStack {
            NavigationLink {
                Text("Detail View")
            } label: {
                VStack {
                    Text("Tap me")
                    Image(systemName: "face.smiling")
                        .foregroundStyle(.yellow)
                        .fontWeight(.bold)
                        .font(.largeTitle)
                }
            }
            .navigationTitle("Swift UI")
        }
    }
}
----------------------
