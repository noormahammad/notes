import Foundation

//---------------------------------------------------------Variables, Strings--------------------------------------------------------------//
let name = "Taylor"
let age = 26
let message = "I am \(name) and I am \(age) years old"
print(age.isMultiple(of: 13))
print(message)
print(message.count)

//boolean
var isSaved = false;
isSaved.toggle()
print(isSaved)

//---------------------------------------------------------Arrays--------------------------------------------------------------//
var myItems = [4, 5, 3, 0, 7, 2, 3]
var colors = ["Red", "Green", "Blue"]
colors.append("Yellow")
myItems.remove(at: 2)
print(myItems[2])

//dictionary
let employee = [
    "name": "Peter",
    "job" : "Enterprise Architect",
    "lastname": "dkfj"
]
print(employee["name", default: "Unknown"])

//---------------------------------------------------------Sets -- duplicates and order are ignored in Sets----------------------------//
var numbers = Set([1,5,3,5,3,7,6])
print(numbers)
numbers.insert(10)
print(numbers.contains(11)) //runs instantly even if the set has 10 million items

//---------------------------------------------------------------Enums---------------------------------------------------------------//
enum Weekday {
    case monday, tuesday, wednesday, thursday, friday
}
var day = Weekday.monday
day = .friday
print(day)

//Type annonation
let player: String = "Tom"
let luckyNumber: Int = 13
let pi: Double = 3.14
let isEnabled: Bool = true

var albums: Array<String> = ["Backstreet boys", "The Green", "Nation"]
var user: Dictionary<String, String> = ["Name": "Peter", "job": "Enterprise Architect"]
var books: Set<String> = Set(["Python for Kids", "Release your Breaks"])

//another syntax for arrays and dictionaries
var albums1: [String] = ["Backstreet boys", "The Green", "Nation"]
var user1: [String: String] = ["Name": "Peter", "job": "Enterprise Architect"]
var books1: Set<String> = Set(["Python for Kids", "Release your Breaks"])

// creating empty collections
var teams: [String] = [String]()
var clues = [String]()

enum UIStyle {
    case light, dark, system
}
var style: UIStyle = .dark

//-----------------------------------------------------------condtions---------------------------------------------------------------------
let age1 = 16

if age1 < 12 {
    print("you cannot vote")
} else if age1 < 18 {
    print("you can soon vote")
} else {
    print("you can vote now")
}

let temp = 26

if temp >= 20 && temp <= 30 {
    print("It's a nice day")
} else if temp < 10 || temp < 20 {
    print("It's cold today")
}

//----------------------------------------------------------switch case---------------------------------------------------------------------
switch style {
case UIStyle.dark :
    print("dark theme active")
case UIStyle.light :
    print("light theme")
default:
    print("theme is other")
}

//---------------------------------------------------------ternary condition operator--------------------------------------------------------
let stockPrice = 99
var isExpensive : Bool = stockPrice > 100 ? true : false

//---------------------------------------------------------------------------Loops-----------------------------------------------------------
//for loop
let stocks = ["MSFT", "MSTR", "AVGO", "IBKR", "TSLA", "AMD"]

for stock in stocks {
    print("stock symbol is \(stock)")
}

for i in 1...10 {
    print(" 8 X \(i) = \(i * 8)")
}

var lyric = "Haters gonna"
//if you dont care about the variable, you can use underscore _
for _ in 1...5 {
    lyric +=  " hate"
}
print(lyric)

//while loop
var count = 10
while count > 0 {
    print("\(count)...")
    count -= 1
}

let files = ["adf.jpg", "work.txt", "sdfdf.jpg", "dsfdsfsdf.csv"]

for file in files {
    if file.hasSuffix(".jpg") == false {
        continue
    }
    print("Found picture \(file)")
}

//-----------------------------------------------------------------------Functions---------------------------------------------------------//
func printTimesTable(number: Int){
    for i in 1...10 {
        print("\(number) x \(i) = \(number *  i)")
    }
}
printTimesTable(number: 4)

func rollDice() -> Int {
    Int.random(in: 1...6)
}

let result = rollDice()
print(result)

func getUser() -> (firstName: String, lastName: String) {
    (firstName: "Peter", lastName: "Theo")
}
let user2 = getUser()
print("Name: \(user2.firstName) \(user2.lastName)")

let (firstName, _) = getUser()
print(firstName)

//if you dont want to pass variable name, then use under score
func isUppercase(_ input: String ) -> Bool {
    input == input.uppercased()
}
let result1 = isUppercase("HELLO HOW ARE YOU?")

func printTimesTable(for number:Int){
    for i in 1...10 {
        print("\(number) x \(i) = \(number * i)")
    }
}
printTimesTable(for: 5)

//default values in parametes

func greet(_ person: String, formal: Bool = false) {
    if formal {
        print("Welcome, \(person)")
    } else {
        print("Hi \(person)")
    }
}
print(greet("Peter", formal:true))
print(greet("Pradeep"))

//Errors
enum PasswordErrors: Error {
    case short, obvious
}

func checkPassword(_ password: String) throws -> String {
    if password.count < 5 {
        throw PasswordErrors.short
    } else if password == "12345" {
        throw PasswordErrors.obvious
    }
    
    if password.count < 10 {
        return "OK"
    } else {
        return "Good"
    }
}

do {
    let result = try checkPassword("12345yhyruytutui")
    print(result)
} catch PasswordErrors.short {
    print("Password is too short")
} catch PasswordErrors.obvious {
    print("Password is too obvious")
} catch { //generic catch all clause
    print("Some error occured")
}

//------------------------------------------------------------Closures-----------------------------------------------------------------//

// you can assign functionality to constant or variable
let sayHello = {
    print("Hello World")
}
sayHello() // you call the closure just like a function

//pass a parameter to the closure

let sayHello1 = { (name: String) -> String in // here the "in" keyword marks end of the segment of the parameters and the return type.
     "Hi, \(name)" //anything after the "in" keyword, is the body of the closure itself
}
print(sayHello1("James"))

let team = ["Gloria", "Susan", "Tiffiny", "Tasha"]
// ---------------------------------- closure filter ----------------------------------------------//
let namesStartWithT = team.filter({(name:String) -> Bool in
    name.hasPrefix("T")
})
print(namesStartWithT)

//---------------simplified clousre syntax---------------------------
let namesStartWithT1 = team.filter({ name in
    name.hasPrefix("T")
})
print(namesStartWithT1)

let namesStartWithT2 = team.filter { name in name.hasPrefix("T")} // trailing closure syntax
print(namesStartWithT2)

let namesStartWithT3 = team.filter {$0.hasPrefix("T") } //short parameter names, $0, $1, etc
print(namesStartWithT3)

//------------------------------------------------------------Struct-----------------------------------------------------------------//

//stuct let us make our own custom data types
struct Album {
    let title: String
    let artist: String
    var isReleased = true
    
    func printSummary() {
        print("\(title) by \(artist)")
    }
    mutating func removeFromSale() {
        isReleased = false
    }
}

var red = Album(title: "Red", artist: "Taylor Swift")
print(red.title)
red.printSummary()
print(red.isReleased)
red.removeFromSale()
print(red.isReleased)

struct Employee {
    let name: String
    var vacationAllowed = 14
    var vacationTaken = 0
    
    var vacationRemaining: Int {
        get {
            vacationAllowed - vacationTaken
        }
        set {
            vacationAllowed = vacationTaken + newValue
        }
    }
}

var person = Employee(name: "Peter")
person.vacationRemaining = 10
print(person.vacationAllowed)


//--------------------------------------Property Observers -- didSet and -----------------------------------------------------------------//
//property observers are pieces of code that runs when a property changes. there are two types. didSet (called after the change) and willSet (called before the property changes)

struct Game {
    var score = 0 {
        didSet { // called after the property is changed
            print("Score is now \(score)")
        }
        willSet { //called before the property value is changed
            print("Score is about to be changed. now it is \(score)")
        }
    }
}

var game = Game()
game.score += 20
game.score -= 5

// Initializers are special functions that run when new instance of the struct is created. It must make sure that all properties inside the struct have all values by the time it finishes. Swift will make one for you automatically for your struct. it is called member-wise initializers. sometimes you can make your own to have custom control

struct Player {
    let name: String
    let number: Int
    
    init(name: String) {
        self.name = name
        self.number = Int.random(in: 1...99)
    }
}

var player1 = Player(name: "Peter")
print(player1.number)

//----------------access controls: private, private(set), File Private, Public--------------------------------------///

struct BankAccount {
    private(set) var funds = 0 //cannot be changed outside of struct
    
    mutating func deposit(amount: Int){
        funds += amount
    }
    mutating func withdraw(amount: Int) {
        funds -= amount
    }
}

var bankAccount1 = BankAccount(funds: 1000)
bankAccount1.deposit(amount: 200)
print("new balance \(bankAccount1.funds)")
bankAccount1.withdraw(amount: 500)
print("new balance\(bankAccount1.funds)")

//-------------------------------Static Properties in Struct --------------------------------------///

struct AppData {
    static let version = "1.3 beta "
    static let settingsFile = "settings.json"
}

print(AppData.version) //access directly throught out the app without having to initilzie the struct


//------------------------------------------------Classes---------------------------------------------------------///

class Employee2 {
    let hours: Int
    
    init(hours: Int) { //initialize is mandatory
        self.hours = hours
    }
    
    func printSummary() {
        print("I work \(hours) hours a day)")
    }
}

class Developer: Employee2 {
    func work() {
        print("I'm coding for \(hours) hours a day")
    }
    //since it is not declaring any additional properties, it does not need sepearte init. it uses the parent init
    override func printSummary() {
        print("I spent \(hours) hours a day fighting over tabs vs spaces")
    }
}

var developer = Developer(hours: 20)
developer.work()
developer.printSummary()

class Vehicle {
    let isElectric: Bool
    
    init(isElectric: Bool) {
        self.isElectric = isElectric
    }
}

class Car: Vehicle {
    let isConvertinle: Bool
    
    init(isConvertinle: Bool, isElectric: Bool) { // initi is mandatory because there is additional property in class Car
        self.isConvertinle = isConvertinle
        super.init(isElectric: isElectric) //need to call parent init using super
    }
}

//copies of class objects share the same data whee as the structs don't. classes are of reference type and structs are value type.
class Actor {
    var name = "Nicolas Cage"
}

var actor1 = Actor()
var actor2 = actor1

actor2.name = "Tom Crise"
print(actor1.name)
print(actor2.name)

//---------------------class deinitializers ---------//
class Site {
    let id: Int
    
    init(id: Int) {
        self.id = id
        print("Site \(id): I've been created")
    }
    
    deinit {
        print("Site \(id): I've been destroyed")
    }
}

for i in 1...3 {
    let site = Site(id: i)
    print("Site \(site.id): I am in control")
} //as soon as the control leaves the iteration, the site created in that iteration will be deinitilized/destroyed

class Singer {
    var name = "Adele"
}

var singer = Singer()
singer.name = "Justin"
print(singer.name) // classes dont' need to have mutating property for their members. it can always change, but not the case for struct


//------------------------------------------------Protocols---------------------------------------------------------///
//protocols define functionality that we expect other types to support and swift will ensure they follow the rules correctly

protocol Vehicle1 {
    var name: String { get }
    var currentPassengers: Int { get set }
    func estimateTime(for distance: Int) -> Int
    func travel(distince: Int)
}

// you can conform multiple protocols also, by simplyng Vehicle1, Protocol2, Protocol3, etc.
//if you want to subclass and then conform to a protocol, add the class first and then protocal1, protocol2, etc.
struct Car1: Vehicle1 {
    let name = "Car"
    var currentPassengers = 1
    func estimateTime(for distance: Int) -> Int {
        distance / 50
    }
    func travel(distince: Int) {
        print("I am driving \(distince) km")
    }
    func openSunroof() {
        print("I's a nice day!")
    }
}

func commute(distance: Int, using vehicle: Vehicle1) {
    if vehicle.estimateTime(for: distance) > 100 {
        print("too slow!")
    } else {
        vehicle.travel(distince: distance)
    }
}

let car3 = Car1()
commute(distance: 100, using: car3)


//----------------------------------------------------------Extensions-----------------------------------------------------------///

extension String {
    func trimmed() -> String {
        self.trimmingCharacters(in: .whitespacesAndNewlines)
    }
    
    mutating func trim() {
        self = self.trimmed()
    }
    
    var lines: [String] {
        self.components(separatedBy: .newlines)
    }
}

var quote = "    hellow world lkdjfsalf  kaldsjf dsf  "
quote.trim()
print(quote)

let lyrics = """
Hello
How are you
What is happening
"""

print("number of lines in this string are: \(lyrics.lines.count)")

// ------------ Protocol extensions -----------------//
//protocol extensions let us add computed properties and methods to the whole protocol so that any types conforming to it will get access to them. For example, arrays, dictionaries and Sets are conformed to the common protocol called "Collections". so when we add a computeed property to that, all 3 of them will get access to it

extension Collection {
    var isNotEmpty: Bool { //computed property
        isEmpty == false
    }
}

let guests = ["Mario", "Goose", "Pathan", "Superman"]

if guests.isNotEmpty {
    print("Guest Count: \(guests.count)")
}

//---------------------------------------------------------- Optionals (Nullables in C#)------------------------------------------------///

let opposites = [
    "Mario": "Wario",
    "Luigi": "Walugigi"
]

let peachOpposite = opposites["Peach"]

if let marioOpposite = opposites["Mario"] {
    print("Mario's opposite is \(marioOpposite)")
}

func printSquare(of number: Int?) {
    guard let number = number else {
        print("Missing input")
        return
    }
    
    //if you are here, that menas number is present and not null
    print("\(number) x \(number) is \(number * number)")
}

printSquare(of: nil)

// Nil Colescent

let tvShows = ["Game of Thrones", "Dexter", "Breaking Bad"]
let favorite = tvShows.randomElement() ?? "None"
print(favorite)

let input = ""
let numner = Int(input) ?? 0
print(numner)

//---------------------------optional chaining ---------

let names = ["Arya", "Bran", "Robb", "Sansa"]

let chosen = names.randomElement()?.uppercased()
print("Next in line: \(chosen ?? "No one")")

///------optional try when there is an error

enum UserError: Error {
    case badID, networkFailed
}

func getUser(id: Int) throws -> String {
    throw UserError.networkFailed
}

if let user = try? getUser(id: 45) { //here we don't care what type of error we get, only care if we get user or not. if you want to know what kind of error is thrown, then use do, try catch blocks
    print("User: \(user)")
}

--------------Swift UI------------------------------
-----using Z-Stack:

import SwiftUI

struct ContentView: View {
    var body: some View {
        ZStack {
            VStack(spacing: 0) {
                Color.red
                Color.blue
            }
            Text("Your Content")
                .padding(50)
                .background(.ultraThinMaterial)
        }.ignoresSafeArea()
    }
}
------- Gradientes ---

--Liner Gradeint 
struct ContentView: View {
    var body: some View {
        ZStack {
            LinearGradient(stops:
                            [.init(color:.white, location: 0.45),
                             .init(color:.black, location: 0.55)
                            ], startPoint: .top, endPoint: .bottom)

            //LinearGradient(colors: [.white, .black], startPoint: .leading, endPoint: .trailing)
        }.ignoresSafeArea()
    }
}

--Radial Gradient 
struct ContentView: View {
    var body: some View {
        ZStack {
            RadialGradient(colors: [.blue, .black], center: .center, startRadius: 20, endRadius: 200)
        }.ignoresSafeArea()
    }
}

--Angular Gradient
struct ContentView: View {
    var body: some View {
        ZStack {
            AngularGradient(colors: [.blue, .red, .green, .purple, .blue], center: .center)
            AngularGradient(stops: [
                .init(color: .blue, location: 0.12),
                .init(color: .red, location: 0.40),
                .init(color: .yellow, location: 0.60),
                .init(color: .purple, location: 0.80),
                .init(color: .blue, location: 0.90)
                
            ], center: .center)
        }.ignoresSafeArea()
    }
}

---In-built gradient on any color
struct ContentView: View {
    var body: some View {
        ZStack {
            Text("Your Content here")
                .frame(maxWidth:.infinity, maxHeight: .infinity)
                .foregroundStyle(.white)
                .background(.indigo.gradient)
        }.ignoresSafeArea()
    }
}

-------------------------------------------------------Buttons and Images---------------------------------------------------------
import SwiftUI

struct ContentView: View {
    @State var message = ""
    @State var count = 0
    @State var isAlertShowing = false
    var body: some View {
        Button("Button 1") {}
            .buttonStyle(.bordered)
        Button("Button 2", role: .destructive) {}
            .buttonStyle(.bordered)
       
        Button("Button 1") {}
            .buttonStyle(.borderedProminent)
        Button("Button 2", role: .destructive) {}
            .buttonStyle(.borderedProminent)
        
        //Custom buttons
        Button {
            printHelloWorld()
        } label: {
            Text("Click me")
                .padding(15)
                .foregroundStyle(.white)
                .font(.largeTitle.weight(.semibold))
                .background(.red)
        }
        
        Image("newyork")
            .clipShape(.capsule)
            .shadow(radius: 5)
        
        // Buttons with sytem image icons (look up icon names using SF Symbols mac os app)
        Button("Delete", systemImage: "trash", role: .destructive, action: printHelloWorld)
        Button("Add", systemImage: "plus") {}
        Button("Edit", systemImage: "pencil"){}.tint(.green)
        Button("Upload", systemImage: "icloud.and.arrow.up.fill") {}.tint(.purple)
        
        //Buttons with action
        Button("Delete Selection", role: .destructive, action: printHelloWorld)
            .buttonStyle(.borderedProminent)
            .tint(.pink)
        Text("\(message)")
    }
    
    func printHelloWorld() {
        if count % 2 == 0 {
            message = "Hello World"
        } else {
            message = ""
        }
        count += 1
    }
}
#Preview {
    ContentView()
}
---------------------------------------Alerts---------------------------------------------
import SwiftUI
struct ContentView: View {
    @State var message = ""
    @State var count = 0
    @State private var isAlertShowing = false
    var body: some View {
        Button("Show Alert", role: .destructive) {
            isAlertShowing = true
        }
        .buttonStyle(.borderedProminent)
        .alert("This is Alert Title", isPresented: $isAlertShowing) {
            Button("OK", role: .destructive) {}
        } message: {
            Text("This is the body of the alert message")
        }
    }
}

----------------------------Guess the flag game--------------------------------------

//
//  ContentView.swift
//  GuessTheFlag
//
//  Created by noor on 2/5/25.
//

import SwiftUI


struct ContentView: View {
    @State private var countries = ["Estonia", "France", "Germany", "Ireland", "Italy", "Monaco", "Nigeria", "Poland", "Spain", "UK", "Ukraine", "US"]
    @State private var correctAnswer: Int = Int.random(in: 0...2)
    @State private var scoreTitle = ""
    @State private var scoreShowing = false
    @State private var score = 0
    @State private var gameOver = false
    @State private var questionCounter = 1
    var body: some View {
        ZStack {
            RadialGradient(stops: [
                .init(color: Color(red: 0.1, green: 0.2, blue: 0.45), location: 0.3),
                .init(color: Color(red: 0.76, green: 0.15, blue: 0.26), location: 0.3)
            ], center: .top, startRadius: 200, endRadius: 700)
            .ignoresSafeArea()
            VStack(spacing: 30) {
                Spacer()
                Text("Guess the Flag")
                    .foregroundStyle(.white)
                    .font(.largeTitle.bold())
                VStack(spacing: 15) {
                    VStack {
                        Text("Tap the flage of")
                            .foregroundStyle(.secondary)
                            .font(.subheadline.weight(.heavy))
                        Text(countries[correctAnswer])
                            .font(.largeTitle.weight(.semibold))
                    }
                    VStack(spacing:15) {
                        ForEach(0..<3){ number in
                            Button {
                                flagTapped(number)
                            } label: {
                                Image(countries[number])
                                    .clipShape(.capsule)
                                    .shadow(radius: 5)
                            } .alert(scoreTitle, isPresented: $scoreShowing){
                                Button("Continue?") {
                                    countries.shuffle()
                                    correctAnswer = Int.random(in: 0...2)
                                    
                                    if questionCounter > 9 {
                                        gameOver = true
                                    } else {
                                        questionCounter += 1
                                    }
                                }
                            }
                            .alert("Game OVer", isPresented: $gameOver){
                                Button("Restart") {
                                    questionCounter = 0
                                    score = 0
                                }
                                Button("Cancel") {
                                    
                                }
                            } message: {
                                Text("Game Over! Do you want to Restart?")
                            }
                        }
                        Text("Qestion \(questionCounter) of 10")
                    }
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 20)
                .background(.regularMaterial)
                .clipShape(.rect(cornerRadius: 20))
                
                Spacer()
                Spacer()
                
                VStack {
                    Text("Score: \(score)")
                        .foregroundStyle(.white)
                        .font(.title.bold())
                }
                Spacer()
            }.padding()
        }
    }
    
    func flagTapped(_ number: Int){
        if number == correctAnswer {
            score +=  1
            scoreTitle = "Correct. Your Score now is: \(score)"
            scoreShowing = true
            
        } else {
            scoreTitle = "Wrong. That's the flag of \(countries[number])"
            scoreShowing = true
        }
    }
}
#Preview {
    ContentView()
}

-------------------Use ternary operators instead of if conditions where possible for performance ---------
---below, if you use if conditions and use two different buttons, swiftUI needs to create two buttons and need to lot of work, where as if ternary operator is used, it only works with one button

import SwiftUI

struct ContentView: View {
    @State private var isUserRead = false
    var body: some View {
        Button("Hello World!") {
            isUserRead.toggle()
        }
        .foregroundStyle(isUserRead ? .blue: .red)
    }
}


---------modifierss-----
import SwiftUI

struct ContentView: View {
    @State private var isUserRead = false
    var body: some View {
        VStack {
            Text("Hello World")
                .font(.largeTitle) //this child modifier overrides the external vstack font modifer
            Text("Hello World")
            Text("Hello World")
            Text("Hello World")
            Text("Hello World")
        }
        .font(.title) //applies to all elements inside the VStack, but child modifers take precedence
    }
}
-----------------------Views as properties----------

import SwiftUI

struct ContentView: View {
    let view1 = Text("Hello World")
    let view2 = Text("How Are you")
    var body: some View {
        VStack {
            view1
            view2
                .foregroundStyle(.red)
        }
    }
}

----------views as computed properties ------
import SwiftUI

struct ContentView: View {
    //computed properties for views
    var view1: some View {
        VStack {
            Text("Hello world")
            Text("How are you")
        }
    }
    //using @ViewBuilder is recommended because that is exactly how body property is defined
    @ViewBuilder var view2 : some View {
        HStack {
            Text("I am fine..")
            Text("How r u doig")
        }
    }
    
    var body: some View {
        VStack {
            view1
            view2
                .foregroundStyle(.red)
        }
    }
}

------------------------------Custom Views -------------------------------

import SwiftUI
//Custom Vieww
struct capsuleText: View {
    var text: String
    var body: some View {
        Text(text)
            .padding()
            .font(.largeTitle)
            .background(.blue)
            .clipShape(.rect(cornerRadius: 15))
    }
}

struct ContentView: View {
    var body: some View {
        VStack(spacing: 15) {
            capsuleText(text: "Hello")
                .foregroundStyle(.white)
            capsuleText(text: "World")
                .foregroundStyle(.red)
        }
    }
}
---------------------------------------------------------------------------









